/* This file is part of libtrevisan, a modular implementation of
   Trevisan's randomness extraction construction.

   Copyright (C) 2011-2012, Wolfgang Mauerer <wm@linux-kernel.net>

   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2
   of the License, or (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with libtrevisan. If not, see <http://www.gnu.org/licenses/>. */

// Generate a list of precomputed irreducible polynomials

#include <NTL/GF2X.h>
#include <NTL/GF2XFactoring.h>
#include <NTL/tools.h>
#include <cstring>
#include <string>
#include <iostream>
#include <sstream>
#include <algorithm>
#include <inttypes.h>

#include <stdlib.h>
#include <stdio.h>

#include "CumffaTypes.h"

NTL_CLIENT

unsigned int field_sizes[] = {8192, 16382};

void convertCharArrayToIntArray( unsigned char* s_value, ufixn* t_value, int num_chars ) {
  
  int offset = 0;
  
  if(num_chars == 0)
    return;
    
  int highest_block_idx = (num_chars-1)/8;
  double j=highest_block_idx+1-0.125;
  
  for(int i=num_chars-1; i>=0; --i) {
    t_value[(int)j] += ((ufixn)s_value[i] << offset);
    
    offset = (offset + 8) % 64;
    j-=0.125;
  }
}

void clearArray( ufixn* array, int size ) {
  for(int i=0; i<size; ++i) {
    array[i] = 0;
  }
}

void printbincharpad(unsigned char* ca, unsigned int n)
{
  for(int j=0; j<n; j++) {
    char c = ca[j];
      for (int i = 7; i >= 0; --i)
      {
          putchar( (c & (1 << i)) ? '1' : '0' );
      }
      putchar(' ');
  }
  putchar('\n');
}

void printbincharpad(int* ca, unsigned int n)
{
  for(int j=0; j<n; j++) {
    int c = ca[j];
      for (int i = 31; i >= 0; --i)
      {
          putchar( (c & (1 << i)) ? '1' : '0' );
      }
      putchar(' ');
  }
  putchar('\n');
}

void gen_irreps_ntl() {
  stringstream ss;
  cout << "// This file is auto-generated by gen_irreps.cc, don't modify" << endl;
  cout << "#include <NTL/GF2X.h>" << endl;
  cout << "#include <sstream>" << endl;
  cout << "#include <iostream>" << endl;
    cout << "#include <cstdlib>" << endl;
  cout << "NTL_CLIENT" << endl;
  cout << "void set_irrep(GF2X &P, unsigned n) {" << endl;
  cout << "stringstream ss;" << endl;
  cout << "switch (n) {" << endl;

  for( unsigned n = 0; n < sizeof(field_sizes)/sizeof(unsigned int); n++ ) 
  {
    GF2X P;
    BuildSparseIrred(P, field_sizes[n]);

    // This way of storage is extremely inefficient. But since
    // we're only talking about a few bytes on a big iron machine,
    // who cares...
    cout << "case " << field_sizes[n] << ":" << endl;
    cout << "ss << \"" << P  << "\";" << endl;
    cout << "ss >> P;" << endl;
    cout << "break;" << endl;
  }

  cout << "default:" << endl;
  cout << " cerr << \"Internal error: n out of bounds!\";" << endl;
  cout << " exit(-1);" << endl;
  cout << "}" << endl;
  cout << "}" << endl;
}

void gen_irreps_openssl() {
  stringstream ss;
  cout << "// This file is auto-generated by gen_irreps.cc, don't modify" << endl;
  cout << "#include <openssl/bn.h>" << endl;
  cout << "#include <iostream>" << endl;
    cout << "#include <cstdlib>" << endl;
    cout << "#include <vector>" << endl;
  cout << "using namespace std;" << endl;
  cout << "void set_irrep(vector<int> &p, unsigned n) {" << endl;
  cout << "switch (n) {" << endl;

  for( unsigned n = 0; n < sizeof(field_sizes)/sizeof(unsigned int); n++ ) 
  {
    GF2X P;
    BuildSparseIrred(P, field_sizes[n]);

    // Sure, there are much more efficient ways to detect the number
    // of set bits
    cout << "case " << field_sizes[n] << ": {" << endl;
    
    for (long i = deg(P); i >= 0; i--) {
      if (coeff(P, i) == 1)
        cout << "p.push_back("  << i << ");" << endl;
    }
    cout << "} break;" << endl;
  }

  cout << "default:" << endl;
  cout << " cerr << \"Internal error: n out of bounds!\";" << endl;
  cout << " exit(-1);" << endl;
  cout << "}" << endl;
  cout << "}" << endl;
}

void gen_irreps_cuda() {
  stringstream ss;
  cout << "// This file is auto-generated by gen_irreps.cc, don't modify" << endl;
  cout << "#include \"CumffaTypes.h\"" << endl;
  cout << "#include <iostream>" << endl;
    cout << "#include <cstdlib>" << endl;
    cout << "#include <vector>" << endl;
  cout << "using namespace std;" << endl;

  cout << "void set_irrep_cuda(vector<ufixn> &p, ufixn n) {" << endl;
  cout << "switch (n) {" << endl;

  for( unsigned n = 0; n < sizeof(field_sizes)/sizeof(unsigned int); n++ ) 
  {
    GF2X P;
    BuildSparseIrred(P, field_sizes[n]);

    // Sure, there are much more efficient ways to detect the number
    // of set bits
    cout << "case " << field_sizes[n] << ": {" << endl;

    long num_bytes = NumBytes(P);
    unsigned char bytes[num_bytes];
    int num_chunks = (num_bytes-1)/sizeof(ufixn)+1;
    ufixn bytes_as_ufixn[num_chunks];
    clearArray(bytes_as_ufixn, num_chunks);

    BytesFromGF2X(bytes, P, num_bytes);

    reverse(bytes, bytes+num_bytes);
    
    long offset = 0;
    long i = 0;
    
    convertCharArrayToIntArray(bytes, bytes_as_ufixn, num_bytes);

    for(int i=0; i<num_chunks; i++) {
      cout << "p.push_back("  << bytes_as_ufixn[i] << "ULL);" << endl;
    }

    cout << "} break;" << endl;
  }

  cout << "default:" << endl;
  cout << " cerr << \"Internal error: n out of bounds!\";" << endl;
  cout << " exit(-1);" << endl;
  cout << "}" << endl;
  cout << "}" << endl;
}

void gen_irreps_cuda_for_py() {
  stringstream ss;
  cout << "# This file is auto-generated by gen_irreps.cc, don't modify" << endl;
  cout << endl;

  cout << "def set_irrep( n ):" << endl;

  cout << endl;
  cout << "\tres = 0" << endl;
  cout << endl;

  for( unsigned n = 0; n < sizeof(field_sizes)/sizeof(unsigned int); n++ ) 
  {
    GF2X P;
    BuildSparseIrred(P, field_sizes[n]);

    // Sure, there are much more efficient ways to detect the number
    // of set bits
    if( field_sizes[n] == 1 )
      cout << "\tif n == " << field_sizes[n] << ":" << endl;
    else
      cout << "\telif n == " << field_sizes[n] << ":" << endl;

    long num_bytes = NumBytes(P);
    unsigned char bytes[num_bytes];

    BytesFromGF2X(bytes, P, num_bytes);

    reverse(bytes, bytes+num_bytes);
    
    long shift = 0;

    for( int i=num_bytes-1; i>=0; --i ) {
      cout << "\t\tres = res + (" << +bytes[i] << " << " << shift << ")" << endl;
      shift = shift + 8;
    }
  }

  cout << endl;
  cout << "\treturn res" << endl;
}

int main(int argc, char **argv) {
  if(strcmp(argv[1], "NTL") == 0) {
    gen_irreps_ntl();
  } else if(strcmp(argv[1], "CUDA") == 0) {
    gen_irreps_cuda();
  } else if(strcmp(argv[1], "PYTHON") == 0) {
    gen_irreps_cuda_for_py();
  } else {
    gen_irreps_openssl();
  }

  return 0;
}
